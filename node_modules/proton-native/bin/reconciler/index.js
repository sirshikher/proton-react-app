"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _emptyObject = _interopRequireDefault(require("fbjs/lib/emptyObject"));

var _createElement = require("../utils/createElement");

var _render = require("../render");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var Reconciler = require('react-reconciler');

var DEBUG = false;
var DesktopRenderer = Reconciler({
  appendInitialChild: function appendInitialChild(parentInstance, child) {
    if (DEBUG) console.log('appendInitialChild');

    _appendChild(parentInstance, child);
  },
  createInstance: function createInstance(type, props, internalInstanceHandle) {
    if (DEBUG) console.log('createInstance');
    return (0, _createElement.createElement)(type, props);
  },
  createTextInstance: function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
    if (DEBUG) console.log('createTextInstance');
    return {
      text: text,
      type: 'text'
    };
  },
  finalizeInitialChildren: function finalizeInitialChildren(wordElement, type, props) {
    if (DEBUG) console.log('finalizeInitialChildren');
    return false;
  },
  getPublicInstance: function getPublicInstance(inst) {
    if (DEBUG) console.log('getPublicInstance');
    return inst;
  },
  prepareForCommit: function prepareForCommit(hostContext) {
    if (DEBUG) console.log('prepareForCommit'); // noop
  },
  prepareUpdate: function prepareUpdate(wordElement, type, oldProps, newProps) {
    if (DEBUG) console.log('prepareUpdate');
    var propKeys = new Set(Object.keys(newProps).concat(Object.keys(oldProps))).values();
    var diff = {};
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = propKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var key = _step.value;

        if ( //key !== "children" && // children are already handled by react-reconciler
        oldProps[key] !== newProps[key]) {
          diff[key] = newProps[key];
        }
      } //console.log(diff);
      //console.log(oldProps, newProps);

    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return diff;
  },
  resetAfterCommit: function resetAfterCommit(hostContext) {
    if (DEBUG) console.log('resetAfterCommit');
    hostContext.afterCommit(hostContext);
  },
  resetTextContent: function resetTextContent(wordElement) {
    if (DEBUG) console.log('resetTextContent'); // noop
  },
  getRootHostContext: function getRootHostContext(instance) {
    if (DEBUG) console.log('getRootHostContext');
    return {};
  },
  getChildHostContext: function getChildHostContext(instance) {
    if (DEBUG) console.log('getChildHostContext');
    return _emptyObject["default"];
  },
  shouldSetTextContent: function shouldSetTextContent(type, props) {
    if (DEBUG) console.log('shouldSetTextContent');
    return false;
  },
  now: function now() {},
  useSyncScheduling: true,
  // MUTATION
  appendChild: function appendChild(parentInstance, child) {
    if (DEBUG) console.log('appendChild');

    _appendChild(parentInstance, child);
  },
  appendChildToContainer: function appendChildToContainer(parentInstance, child) {
    if (DEBUG) console.log('appendChildToContainer');

    _appendChild(parentInstance, child);
  },
  removeChild: function removeChild(parentInstance, child) {
    if (DEBUG) console.log('removeChild');

    _removeChild(parentInstance, child);
  },
  removeChildFromContainer: function removeChildFromContainer(parentInstance, child) {
    if (DEBUG) console.log('removeChildFromContainer');

    _removeChild(parentInstance, child);
  },
  insertBefore: function insertBefore(parentInstance, child, beforeChild) {
    if (DEBUG) console.log('insertBefore');
    insertChild(parentInstance, child, beforeChild);
  },
  commitUpdate: function commitUpdate(instance, updatePayload, type, oldProps, newProps) {
    if (DEBUG) console.log('commitUpdate'); //console.log("UPDATE", instance, updatePayload);

    instance.updateProps(updatePayload);
  },
  commitMount: function commitMount(instance, updatePayload, type, oldProps, newProps) {
    if (DEBUG) console.log('commitMount'); // noop
  },
  commitTextUpdate: function commitTextUpdate(textInstance, oldText, newText) {
    if (DEBUG) console.log('commitTextUpdate'); //console.log("TEXT UPDATE", newText);

    textInstance.text = newText;
    textInstance.parent.updateText();
  },
  supportsMutation: true,
  supportsPersistence: false
});

var _appendChild = function _appendChild(container, child) {
  //console.log("ADD", child);
  if (container.appendChild) {
    if (_typeof(child) == 'object') child.parent = container;
    container.appendChild(child, container);
    if (child.element && child.element.show) child.element.show(); // TODO: Should this be here?
  } else {
    throw new Error("Can't append child to ".concat(container.constructor.name));
  }
};

var _removeChild = function _removeChild(container, child) {
  //console.log("REMOVE", child);
  if (container.removeChild) {
    container.removeChild(child, container);
  } else {
    throw new Error("Can't remove child from ".concat(container.constructor.name));
  }
};

var insertChild = function insertChild(container, child, beforeChild) {
  if (container.insertChild) {
    if (_typeof(child) == 'object') child.parent = container;
    container.insertChild(child, beforeChild, container);
    if (child.element && child.element.show) child.element.show(); // TODO: Should this be here?
  } else {
    throw new Error("Can't append child to ".concat(container.constructor.name));
  }
};

var _default = DesktopRenderer;
exports["default"] = _default;